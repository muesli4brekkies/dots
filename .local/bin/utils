#!/bin/bash
[ $DISTRO == "arch" ] && {
	logfile="/var/log/pacman.log"
	update_rx="full system upgrade$"
	 __stripTime__() { date +%s -d $(awk '{gsub("[\\[\\]]",""); print $1; exit}' $1); }
}

[ $DISTRO == "gentoo" ] && {
	logfile="/var/log/emerge.log"
	update_rx="newuse.+update.+deep.+world"
	__stripTime__() { awk -F: '{print $1; exit}' $1; }
}

__timeDiff__() {
	secs=$(( $(date +%s) - $1 ))
	divmod(){ printf $(( secs / $1 % $2)); }

	niceStr(){ [ $1 -gt 0 ] && printf "%s %s%s, " $1 $2 $([ $1 -gt 1 ] && printf "s"); }
	outstr=$(\
cat << EOF
$(niceStr $((secs / 86400 % 999999)) "day")\
$(niceStr $((secs / 3600 % 24)) "hour")\
$(niceStr $((secs / 60 % 60)) "min")
EOF
	)
	sed -E 's/, $//' <([ "$outstr" ] && printf "$outstr" || printf "$(niceStr $(divmod 1 60) "second")")
}

system-age() {
	__timeDiff__ $(__stripTime__ $logfile)
}

last-update() {
	__timeDiff__ $(__stripTime__ <(tac $logfile | grep -Em1 "${update_rx}" ))
}

last-login() {
	__timeDiff__ $(date +%s -d $(last $USER -5i --time-format iso | awk '{ if ($4==last || last=="") { last=$4 } else { print $4; exit } }'))
}

uptime() {
	__timeDiff__ $(date +%s -d "$(/usr/bin/uptime -s)")
}

gui() {
	#read -n1 -p "0=niri, 1=awesome: " v
	read -n1 -p "0=niri, 1=awesome: " a
	case $a in
		0) exec niri-session ;;
		1) exec startx ;;
		*) printf "\nyou suck, type one of the numbers\n" ;;
	esac
}

pow() {
	acfn() {
		[ $(cat $dir/{AC,AC0,ADP1}/online 2>/dev/null) -eq 1 ] && printf "+" || printf "-"
	}
	local dir="/sys/class/power_supply"
	if test ! -d $dir/BAT0;then printf "no batt"; return 0; fi
	printf '%s%%%s' $(cat $dir/BAT0/capacity 2>/dev/null) $(acfn)
}

ansi() {
	help() {
		printf '%s\n' "[ usage ]" 'utils ansi red bright' 'utils ansi rgb 0 100 255' 'utils ansi hex fe dc ba' 'utils ansi rgb abcdef' >&2
	
		exit 1
	}
	case $1 in
		rgb|hex)
		local r=$2
		local g=$3
		local b=$4
		if [ $1 = "hex" ]; then
			if [ $# -eq 2 ]; then
				hex=($(sed -E 's/(..)(..)(..)/\1 \2 \3/g' <<< $2))
				r=${hex[0]}
				g=${hex[1]}
				b=${hex[2]}
			fi
			r=$((16#$r))
			g=$((16#$g))
			b=$((16#$b))
		fi
		if [ "$r" ] && [ "$g" ] && [ "$b" ]; then
			printf "\e[38;2;$r;$g;${b}m"
			return 0
		else
			err "bad $1 code"
			help
		fi
		;;
		(k|b|black|key) col=0;;
		(r|red)         col=1;;
		(g|gr|green)    col=2;;
		(y|yel|yello)   col=3;;
		(b|bl|blue)     col=4;;
		(m|mag|magenta) col=5;;
		(c|cy|cyan)     col=6;;
		(w|whi|white)   col=7;;
		*) printf "dunno what a \"$1\" might be\n" >&2
		help
	esac
	printf '\e[%s%sm' $(case $2 in (b|br|bri|bright) echo 9;; *) echo 3;; esac) $col
}

err() { 1>&2 echo $@; exit 1; }

args=($@); case $(type -t $1) in function) $1 ${args[@]:1} || err "that didn't work";; *) err "${1} is not a function";; esac
